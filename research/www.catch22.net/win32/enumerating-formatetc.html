<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  
<!-- Mirrored from www.catch22.net/tuts/win32/enumerating-formatetc by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Enumerating FORMATETC - Catch22</title>
<meta name="description" content="">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Catch22">
<meta property="og:title" content="Enumerating FORMATETC">
<meta property="og:url" content="enumerating-formatetc.html">


  <meta property="og:description" content="">







  <meta property="article:published_time" content="2004-06-16T00:00:00+00:00">






<link rel="canonical" href="enumerating-formatetc.html">













<!-- end _includes/seo.html -->


<link href="http://www.catch22.net/feed.xml" type="application/atom+xml" rel="alternate" title="Catch22 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="http://www.catch22.net/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--tutorial wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="http://www.catch22.net/">Catch22</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="http://www.catch22.net/blog/" >Blog</a>
            </li><li class="masthead__menu-item">
              <a href="http://www.catch22.net/software/" >Software</a>
            </li><li class="masthead__menu-item">
              <a href="../index.html" >Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="http://www.catch22.net/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="http://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="http://www.catch22.net/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="http://www.catch22.net/tuts" itemprop="item"><span itemprop="name">Tuts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="../win32.html" itemprop="item"><span itemprop="name">Win32</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        <li class="current">Enumerating FORMATETC</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
    
      
  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="http://www.catch22.net/assets/files/tuts/win32/enumformat.zip dataobjview.zip">enumformat.zip dataobjview.zip</a>      
    
  </div>

    
    

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Enumerating FORMATETC">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="June 16, 2004">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Enumerating FORMATETC
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <!--h1>Enumerating FORMATETC</h1-->
<!--h3>Standalone implementation of the IEnumFormatEtc interface</h3-->

<p><img src="http://www.catch22.net/assets/img/dragdrop08.gif" alt="" class="align-center" /></p>

<p>This tutorial will concentrate on implementing a COM object which exposes the <code class="highlighter-rouge">IEnumFORMATETC</code> interface. There are two code downloads this time. The first includes a complete implementation of a generic <code class="highlighter-rouge">IEnumFORMATETC</code> which you can use in your applications.</p>

<p>The second code download is the full source code to an application called “IDataObject Viewer”. This is an replacement for the PlatformSDK program of the same name. It is basically a demonstration of how to <em>use</em> the <code class="highlighter-rouge">IEnumFORMATETC</code> interface rather than <em>write</em> it. More important though, it is a very useful tool for debugging OLE drag and drop code because you can drag _any_form of IDataObject onto it, and it will display the available formats of data contained within it. Give it a go!</p>

<p>The <code class="highlighter-rouge">IEnumFORMATETC</code> interface is quite often overlooked when beginning drag and drop. In some cases it is not necessary, but to be 100% sure that your IDataObject will work under all conditions it is wise to provide a full implementation of this interface.</p>

<table>
  <tbody>
    <tr>
      <td>IEnumFORMATETC Methods</td>
      <td>Description</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Next</code></td>
      <td>Return the next <code class="highlighter-rouge">FORMATETC</code> structure in the enumeration.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Skip</code></td>
      <td>Skip the specified number of <code class="highlighter-rouge">FORMATETC</code> structures (i.e. don’t return them).</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Reset</code></td>
      <td>Return the enumeration to the beginning.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Clone</code></td>
      <td>Return an identical <code class="highlighter-rouge">IEnumFORMATETC</code> interface to the current one, with the exact same underlying state.</td>
    </tr>
  </tbody>
</table>

<p>The diagram below should help to illustrate the concept of the <code class="highlighter-rouge">IEnumFORMATETC</code> interface.</p>

<p><img src="http://www.catch22.net/assets/img/dragdrop07.gif" alt="" class="align-center" /></p>

<p>The enumeration contains three items, with the “enumeration index” initially starting at the first item (index zero).</p>

<ol>
  <li>The <code class="highlighter-rouge">Next</code> method is called to return the first <code class="highlighter-rouge">FORMATETC</code> structure at <strong>index zero</strong> , and as a side effect advances the enumerator to <strong>index 1</strong>.</li>
  <li>The <code class="highlighter-rouge">Skip</code> method is called (with an argument of 2, skipping two positions), advancing to the end of the enumeration ( <strong>index 3</strong> ).</li>
  <li>The <code class="highlighter-rouge">Reset</code> method is called to return the index back to the start ( <strong>index zero</strong> ).</li>
</ol>

<p>The <code class="highlighter-rouge">IEnumFORMATETC</code> is actually very simple as there are only four methods to implement:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CEnumFormatEtc</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEnumFORMATETC</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="c1">//
</span>    <span class="c1">// IUnknown members
</span>    <span class="c1">//
</span>    <span class="n">HRESULT</span> <span class="kr">__stdcall</span> <span class="n">QueryInterface</span> <span class="p">(</span><span class="n">REFIID</span> <span class="n">iid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span> <span class="n">ppvObject</span><span class="p">);</span>
    <span class="n">ULONG</span> <span class="kr">__stdcall</span> <span class="n">AddRef</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">ULONG</span> <span class="kr">__stdcall</span> <span class="n">Release</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

    <span class="c1">//
</span>    <span class="c1">// IEnumFormatEtc members
</span>    <span class="c1">//
</span>    <span class="n">HRESULT</span> <span class="kr">__stdcall</span> <span class="n">Next</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">celt</span><span class="p">,</span> <span class="n">FORMATETC</span> <span class="o">*</span> <span class="n">rgelt</span><span class="p">,</span> <span class="n">ULONG</span> <span class="o">*</span> <span class="n">pceltFetched</span><span class="p">);</span>
    <span class="n">HRESULT</span> <span class="kr">__stdcall</span> <span class="n">Skip</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">celt</span><span class="p">);</span> 
    <span class="n">HRESULT</span> <span class="kr">__stdcall</span> <span class="n">Reset</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">HRESULT</span> <span class="kr">__stdcall</span> <span class="n">Clone</span> <span class="p">(</span><span class="n">IEnumFORMATETC</span> <span class="o">**</span> <span class="n">ppEnumFormatEtc</span><span class="p">);</span>

    <span class="c1">//
</span>    <span class="c1">// Construction / Destruction
</span>    <span class="c1">//
</span>    <span class="n">CEnumFormatEtc</span><span class="p">(</span><span class="n">FORMATETC</span> <span class="o">*</span><span class="n">pFormatEtc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nNumFormats</span><span class="p">);</span>
    <span class="o">~</span><span class="n">CEnumFormatEtc</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">LONG</span> <span class="n">m_lRefCount</span><span class="p">;</span> <span class="c1">// Reference count for this COM interface
</span>    <span class="n">ULONG</span> <span class="n">m_nIndex</span><span class="p">;</span> <span class="c1">// current enumerator index
</span>    <span class="n">ULONG</span> <span class="n">m_nNumFormats</span><span class="p">;</span> <span class="c1">// number of FORMATETC members
</span>    <span class="n">FORMATETC</span> <span class="o">*</span> <span class="n">m_pFormatEtc</span><span class="p">;</span> <span class="c1">// array of FORMATETC objects
</span><span class="p">};</span>
</code></pre></div></div>

<h2 id="constructing-an-ienumformatetc-object">Constructing an IEnumFORMATETC object</h2>

<p>The most complex aspect of the <code class="highlighter-rouge">IEnumFORMATETC</code> is creating the object, and implementing the COM methods is really very simple after this. Well, creating one is very easy, because all we need to do is use the C++ <strong>operator new</strong> to do this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IEnumFORMATETC</span> <span class="o">*</span><span class="n">pEnumFormatEtc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CEnumFormatEtc</span><span class="p">(</span> <span class="n">fmtetc</span><span class="p">,</span> <span class="n">numfmts</span> <span class="p">);</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CEnumFormatEtc</span><span class="o">::</span><span class="n">CFormatEtc</span><span class="p">(</span><span class="n">FORMATETC</span> <span class="o">*</span><span class="n">pFormatEtc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nNumFormats</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_lRefCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">m_nIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">m_nNumFormats</span> <span class="o">=</span> <span class="n">nNumFormats</span><span class="p">;</span>
    <span class="n">m_pFormatEtc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FORMATETC</span><span class="p">[</span><span class="n">nNumFormats</span><span class="p">];</span>

    <span class="c1">// make a new copy of each FORMATETC structure
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nNumFormats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DeepCopyFormatEtc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_pFormatEtc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pFormatEtc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s break down what this C++ constructor does. It takes two arguments - a pointer to an array of FORMATETC structures, and an integer specifying how many items there are in the array.</p>

<p>The first line initializes the object’s reference count - this is standard across all COM objects and we should be pretty familiar with this, so I won’t cover this any further.</p>

<p>The next set of tasks involves initializing the enumeration’s state. The member variable <code class="highlighter-rouge">m_nIndex</code> represents the current position within the enumeration, so it is natural for this to start at zero. Likewise, the <code class="highlighter-rouge">m_nNumFormats</code> variable is used to represent the end of the enumeration. With just these two variables we can keep track of the enumeration’s current position and ending position.</p>

<p>The most important step is to allocate a new copy of the <code class="highlighter-rouge">FORMATETC</code> array that was passed in as an argument. An array is allocated ( <code class="highlighter-rouge">m_pFormatEtc</code> ) which will hold all the structures that will be enumerated. Each enumeration needs to have it’s own private “cache” of <code class="highlighter-rouge">FORMATETC</code> structures. The key detail is the way that the <code class="highlighter-rouge">FORMATETC</code> structures are copied - here, a new function has been introduced called <code class="highlighter-rouge">DeepCopyFormatEtc</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DeepCopyFormatEtc</span><span class="p">(</span><span class="n">FORMATETC</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">FORMATETC</span> <span class="o">*</span><span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// copy the source FORMATETC into dest
</span>    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">ptd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// allocate memory for the DVTARGETDEVICE if necessary
</span>        <span class="n">dest</span><span class="o">-&gt;</span><span class="n">ptd</span> <span class="o">=</span> <span class="p">(</span><span class="n">DVTARGETDEVICE</span><span class="o">*</span><span class="p">)</span><span class="n">CoTaskMemAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DVTARGETDEVICE</span><span class="p">));</span>

        <span class="c1">// copy the contents of the source DVTARGETDEVICE into dest-&gt;ptd
</span>        <span class="o">*</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">ptd</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">ptd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first line of this function is deceptively simple:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
</code></pre></div></div>

<p>This is just shorthand “C” notation for a standard <code class="highlighter-rouge">memcpy</code>. In fact, this is almost all that is required because it correctly performs a binary copy of the contents of one <code class="highlighter-rouge">FORMATETC</code> structure to another. The problem arises when the source <code class="highlighter-rouge">FORMATETC::ptd</code> member has been initialized to point to a <code class="highlighter-rouge">DVTARGETDEVICE</code> structure.</p>

<p>Just performing a memcpy of the <code class="highlighter-rouge">FORMATETC</code>’s is not enough, because both <code class="highlighter-rouge">FORMATETC</code> structure point to the original <code class="highlighter-rouge">DVTARGETDEVICE</code>. It is therefore necessary to make our own private copy of this structure.</p>

<p>The documentation for <code class="highlighter-rouge">IEnumFORMATETC::Next</code> states that the caller must use <code class="highlighter-rouge">CoTaskMemFree</code> API to free the <code class="highlighter-rouge">DVTARGETDEVICE</code> structure. This logically implies that the structure must have first been allocated using <code class="highlighter-rouge">CoTaskMemAlloc</code> , so this is what the DeepCopy function does - allocates a new <code class="highlighter-rouge">DVTARGETDEVICE</code> structure using <code class="highlighter-rouge">CoTaskMemAlloc</code> and sets <code class="highlighter-rouge">dest-&gt;ptd</code> to point to it instead of the original one. Then the <code class="highlighter-rouge">source-&gt;DVTARGETDEVICE</code> structure is copied across to the new one.</p>

<h2 id="cleaning-up-an-ienumformatetc-object">Cleaning up an IEnumFORMATETC object</h2>

<p>The C++ destructor for the <code class="highlighter-rouge">CEnumFormatEtc</code> class must cleanup any memory allocation that was performed in the constructor.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CEnumFormatEtc</span><span class="o">::~</span><span class="n">CEnumFormatEtc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// first free any DVTARGETDEVICE structures
</span>    <span class="k">for</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_nNumFormats</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m_pFormatEtc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptd</span><span class="p">)</span>
            <span class="n">CoTaskMemFree</span><span class="p">(</span><span class="n">m_pFormatEtc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// now free the main array
</span>    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_pFormatEtc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is basically a simple task of calling <code class="highlighter-rouge">CoTaskMemFree</code> to deallocate any of the <code class="highlighter-rouge">DVTARGETDEVICE</code> structures that were allocated in the constructor. Once these have been freed, the main <code class="highlighter-rouge">m_pFormatEtc</code> array is deallocated.</p>

<h2 id="replacing-shcreatestdenumfmtetc">Replacing SHCreateStdEnumFmtEtc</h2>

<p>You may be wondering why we are bothering with this tutorial at all, because the <code class="highlighter-rouge">SHCreateStdEnumFmtEtc</code> API call can be used to create a full instantiation of the <code class="highlighter-rouge">IEnumFORMATETC</code> interface:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">SHCreateStdEnumFmtEtc</span><span class="p">(</span><span class="n">UINT</span> <span class="n">cfmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">FORMATETC</span> <span class="n">afmt</span><span class="p">[],</span> <span class="n">IEnumFORMATETC</span> <span class="o">**</span><span class="n">ppenumFormatEtc</span><span class="p">);</span>
</code></pre></div></div>

<p>Unfortunately this API call only exists on Windows 2000 and above, so unless you are prepared to drop support for any older version of Windows, we still have to implement <code class="highlighter-rouge">IEnumFORMATETC</code>. What we will do though, is write a drop-in replacement version of <code class="highlighter-rouge">SHCreateStdEnumFmtEtc</code> which we can easily switch from once we decide to support only Windows 2000. Our version will look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="nf">CreateEnumFormatEtc</span><span class="p">(</span><span class="n">UINT</span> <span class="n">cfmt</span><span class="p">,</span> <span class="n">FORMATETC</span> <span class="o">*</span><span class="n">afmt</span><span class="p">,</span> <span class="n">IEnumFORMATETC</span> <span class="o">**</span><span class="n">ppEnumFormatEtc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cfmt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">afmt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ppEnumFormatEtc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E_INVALIDARG</span><span class="p">;</span>

    <span class="o">*</span><span class="n">ppEnumFormatEtc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CEnumFormatEtc</span><span class="p">(</span><span class="n">afmt</span><span class="p">,</span> <span class="n">cfmt</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">ppEnumFormatEtc</span><span class="p">)</span> <span class="o">?</span> <span class="n">S_OK</span> <span class="o">:</span> <span class="n">E_OUTOFMEMORY</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function is very simple because all the hard work has been done in the <code class="highlighter-rouge">CEnumFormatEtc</code> constructor. All we need to do is create a new instance of the class (using the <code class="highlighter-rouge">new</code> operator) and return it in the pointer specified as the last parameter. The rest of the code is simply error checking.</p>

<p>Using this API is really simple:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FORMATETC</span> <span class="n">fmtetc</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CF_TEXT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DVASPECT_CONTENT</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">TYMED_HGLOBAL</span> <span class="p">};</span>
<span class="n">IEnumFORMATETC</span> <span class="o">*</span><span class="n">pEnumFormatEtc</span><span class="p">;</span> 

<span class="n">CreateEnumFormatEtc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fmtetc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pEnumFormatEtc</span><span class="p">);</span>
</code></pre></div></div>

<p>This may seem to be alot of work just to enumerate some simple <code class="highlighter-rouge">FORMATETC</code> structures, but it is worth it because our COM enumerator will now be truly stand-alone, and the rest of the interface is now very simple to implement.</p>

<h2 id="ienumformatetcreset">IEnumFORMATETC::Reset</h2>

<p>The purpose of this member is really simple - start the enumeration again from the beginning.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">CEnumFormatEtc</span><span class="o">::</span><span class="n">Reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_nIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">S_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The implementation above should be self-explanatory.</p>

<h2 id="ienumformatetcskip">IEnumFORMATETC::Skip</h2>

<p>Again the implementation is so straight-forward practically no explanation is required.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">CEnumFormatEtc</span><span class="o">::</span><span class="n">Skip</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">celt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_nIndex</span> <span class="o">+=</span> <span class="n">celt</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m_nIndex</span> <span class="o">&lt;=</span> <span class="n">m_nNumFormats</span><span class="p">)</span> <span class="o">?</span> <span class="n">S_OK</span> <span class="o">:</span> <span class="n">S_FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function merely advances the enumeration by the specified number of units. Note that although no attempt is made to keep the index within the range of the enumeration, the error value returned does indicate whether or not the enumeration has been advanced too far.</p>

<h2 id="ienumformatetcclone">IEnumFORMATETC::Clone</h2>

<p>The clone function may seem a little mysterious at first. Although I have very rarely seen this function called it is quite simple to implement so it doesn’t hurt to do it anyway.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">CEnumFormatEtc</span><span class="o">::</span><span class="n">Clone</span><span class="p">(</span><span class="n">IEnumFORMATETC</span> <span class="o">**</span><span class="n">ppEnumFormatEtc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hResult</span><span class="p">;</span>

    <span class="c1">// make a duplicate enumerator
</span>    <span class="n">hResult</span> <span class="o">=</span> <span class="n">CreateEnumFormatEtc</span><span class="p">(</span><span class="n">m_nNumFormats</span><span class="p">,</span> <span class="n">m_pFormatEtc</span><span class="p">,</span> <span class="n">ppEnumFormatEtc</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">hResult</span> <span class="o">==</span> <span class="n">S_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// manually set the index state
</span>        <span class="p">((</span><span class="n">CEnumFormatEtc</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ppEnumFormatEtc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">m_nIndex</span> <span class="o">=</span> <span class="n">m_nIndex</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">hResult</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The code above simply creates a new instance of the <code class="highlighter-rouge">IEnumFORMATETC</code> interface, using the <code class="highlighter-rouge">CreateEnumFormatEtc</code> function we wrote earlier. The current enumeration’s internal state is used, so the effect is a duplicate interface with the same internal state.</p>

<p>The complicated looking cast inside the “if-clause” is used to preserve the index position of the enumeration. The cast is necessary because the <code class="highlighter-rouge">IEnumFORMATETC</code> interface has no accessible internal variables. However, we know that the <code class="highlighter-rouge">ppEnumFormatEtc</code> is really a <code class="highlighter-rouge">CEnumFormatEtc</code>, so this is a safe cast to perform. The cast operation looks more complicated than it is because we also have to dereference the <code class="highlighter-rouge">ppEnumFormatEtc</code> parameter, in order to access the pointer-to-<code class="highlighter-rouge">IEnumFORMATETC</code> that was stored there.</p>

<h2 id="ienumformatetcnext">IEnumFORMATETC::Next</h2>

<p>The <code class="highlighter-rouge">Next</code> member function is a little more involved than the others.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">CEnumFormatEtc</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">celt</span><span class="p">,</span> <span class="n">FORMATETC</span> <span class="o">*</span><span class="n">pFormatEtc</span><span class="p">,</span> <span class="n">ULONG</span> <span class="o">*</span><span class="n">pceltFetched</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// copy the FORMATETC structures into the caller's buffer
</span>    <span class="k">while</span><span class="p">(</span><span class="n">m_nIndex</span> <span class="o">&lt;</span> <span class="n">m_nNumFormats</span> <span class="o">&amp;&amp;</span> <span class="n">copied</span> <span class="o">&lt;</span> <span class="n">celt</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">DeepCopyFormatEtc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pFormatEtc</span><span class="p">[</span><span class="n">copied</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">m_pFormatEtc</span><span class="p">[</span><span class="n">m_nIndex</span><span class="p">]);</span>
        <span class="n">copied</span><span class="o">++</span><span class="p">;</span>
        <span class="n">m_nIndex</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// store result
</span>    <span class="k">if</span><span class="p">(</span><span class="n">pceltFetched</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
        <span class="o">*</span><span class="n">pceltFetched</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>

    <span class="c1">// did we copy all that was requested?
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="n">celt</span><span class="p">)</span> <span class="o">?</span> <span class="n">S_OK</span> <span class="o">:</span> <span class="n">S_FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function looks quite complicated but can be broken down into three major operations. The major portion of the code is the while-loop which is responsible for copying <code class="highlighter-rouge">FORMATETC</code> structures (using the deep-copy routine). The loop is structured in such a way that only “in-range” elements are copied into the supplied buffer.</p>

<p>The second part of the code returns the actual number of items copied, and returns an error value indicating whether or not all the requested items were copied.</p>

<p>The final section merely returns an error value indicating success or failure to copy the requested number of items.</p>

<h2 id="coming-up-in-part-5---idropsource">Coming up in Part 5 - IDropSource</h2>

<p>Well that’s it for the <code class="highlighter-rouge">IEnumFORMATETC</code> interface. What we have now is a complete, stand-alone implementation, and a very handy <code class="highlighter-rouge">CreateEnumFormatEtc</code> API to easily create enumerator interfaces.</p>

<p>The next part of this tutorial series will be the <code class="highlighter-rouge">IDropSource</code> interface. It’s been a long time coming but hopefully it will be worth the wait!</p>

<p>Don’t forget to check out the IDataObject Viewer utility also!</p>



  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="http://www.catch22.net/assets/files/tuts/win32/enumformat.zip dataobjview.zip">enumformat.zip dataobjview.zip</a>      
    
  </div>

        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2004-06-16T00:00:00+00:00">June 16, 2004</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="2004-06-15-ole-data-transfers/index.html" class="pagination--pager" title="OLE Data Transfers
">Previous</a>
    
    
      <a href="drop-source.html" class="pagination--pager" title="Drop Source
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="http://www.catch22.net/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Catch22. Powered by <a href="https://jekyllrb.com/" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="http://www.catch22.net/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>








  </body>

<!-- Mirrored from www.catch22.net/tuts/win32/enumerating-formatetc by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:45 GMT -->
</html>
