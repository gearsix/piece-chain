<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  
<!-- Mirrored from www.catch22.net/tuts/neatpad/more-uniscribe-mysteries by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>More Uniscribe Mysteries - Catch22</title>
<meta name="description" content="Uniscribe Mysteries continued…">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Catch22">
<meta property="og:title" content="More Uniscribe Mysteries">
<meta property="og:url" content="more-uniscribe-mysteries.html">


  <meta property="og:description" content="Uniscribe Mysteries continued…">







  <meta property="article:published_time" content="2006-03-02T00:00:00+00:00">






<link rel="canonical" href="more-uniscribe-mysteries.html">













<!-- end _includes/seo.html -->


<link href="https://www.catch22.net/feed.xml" type="application/atom+xml" rel="alternate" title="Catch22 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://www.catch22.net/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--tutorial wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="https://www.catch22.net/">Catch22</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://www.catch22.net/blog/" >Blog</a>
            </li><li class="masthead__menu-item">
              <a href="https://www.catch22.net/software/" >Software</a>
            </li><li class="masthead__menu-item">
              <a href="../index.html" >Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://www.catch22.net/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="http://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="http://www.catch22.net/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="https://www.catch22.net/tuts" itemprop="item"><span itemprop="name">Tuts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="../neatpad.html" itemprop="item"><span itemprop="name">Neatpad</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        <li class="current">More Uniscribe Mysteries</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Neatpad</span>
        

        
        <ul>
          
            
            

            
            

            <li><a href="#" class=""></a></li>
          
            
            

            
            

            <li><a href="neatpad-overview.html" class="">Neatpad Overview</a></li>
          
            
            

            
            

            <li><a href="loading-text-file.html" class="">Loading a text file</a></li>
          
            
            

            
            

            <li><a href="scrollbars-scrolling.html" class="">Scrollbars & Scrolling</a></li>
          
            
            

            
            

            <li><a href="enhanced-drawing-painting.html" class="">Enhanced Drawing & Painting</a></li>
          
            
            

            
            

            <li><a href="mouse-selection-highlighting.html" class="">Mouse Selection & Highlighting</a></li>
          
            
            

            
            

            <li><a href="scrolling-mouse.html" class="">Scrolling with the Mouse</a></li>
          
            
            

            
            

            <li><a href="margins-and-long-lines.html" class="">Margins and Long Lines</a></li>
          
            
            

            
            

            <li><a href="introduction-unicode.html" class="">Introduction to Unicode</a></li>
          
            
            

            
            

            <li><a href="unicode-text-processing.html" class="">Unicode Text Processing</a></li>
          
            
            

            
            

            <li><a href="transparent-text.html" class="">Transparent Text</a></li>
          
            
            

            
            

            <li><a href="introduction-uniscribe.html" class="">Introduction to Uniscribe</a></li>
          
            
            

            
            

            <li><a href="uniscribe-mysteries.html" class="">Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="more-uniscribe-mysteries.html" class="active">More Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="drawing-styled-text-uniscribe.html" class="">Drawing styled text with Uniscribe</a></li>
          
            
            

            
            

            <li><a href="integrating-usplib.html" class="">Integrating UspLib</a></li>
          
            
            

            
            

            <li><a href="keyboard-navigation.html" class="">Keyboard Navigation</a></li>
          
            
            

            
            

            <li><a href="piece-chains.html" class="">Piece Chains</a></li>
          
            
            

            
            

            <li><a href="unicode-text-editing.html" class="">Unicode Text Editing</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>
    

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="More Uniscribe Mysteries">
    <meta itemprop="description" content="Uniscribe Mysteries continued…">
    <meta itemprop="datePublished" content="March 02, 2006">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">More Uniscribe Mysteries
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <!--h1>More Uniscribe Mysteries</h1-->
<!--h3>Looking at ScriptShape and ScriptPlace</h3-->

<h2 id="uniscribe-mysteries-continued">Uniscribe Mysteries continued…</h2>

<p>We are going to pick up directly from where we left the last tutorial, in which we began to look at the Uniscribe API in detail. Remember that we are still working on the <code class="highlighter-rouge">UspAnalyze</code> function, and the sequence of events last time had led us to the point where we had broken a string of Unicode text into several item-runs. Below are the steps we made to get this far:</p>

<ol>
  <li><code class="highlighter-rouge">ScriptItemize</code> - to break the string into distinct scripts or “item-runs”.</li>
  <li>Merge item runs with application-defined “style” runs to produce finer-grained items.</li>
  <li><code class="highlighter-rouge">ScriptLayout</code> - to potentially reorder the items.</li>
</ol>

<p>The result of this work was an array of <code class="highlighter-rouge">ITEM_RUN</code> structures (called <code class="highlighter-rouge">itemRunList</code>) and the visual-logical mapping array (called visualToLogicalList) - which tells us in what order to display the runs. Both these arrays are stored inside the <code class="highlighter-rouge">USPDATA</code> object:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">USPDATA</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="n">ITEM_RUN</span> <span class="o">*</span> <span class="n">itemRunList</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">itemRunCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">visualToLogicalList</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The next task is to take each item-run in turn and get to the point where we can actually render some text (using <code class="highlighter-rouge">ScriptTextOut</code>). This will involve calling two more closely related Uniscribe functions (<code class="highlighter-rouge">ScriptShape</code> and <code class="highlighter-rouge">ScriptPlace</code>) for each run. Below are the steps we will now follow:</p>

<ol>
  <li><code class="highlighter-rouge">ScriptShape</code> - to apply contextual shaping behaviour and convert the <em>characters</em> from each run into a series of <em>glyphs</em>.</li>
  <li><code class="highlighter-rouge">ScriptPlace</code> - to calculate the width and positions of each glyph in the run.</li>
  <li>Apply colouring/highlighting to the individual <em>glyphs</em>.</li>
  <li><code class="highlighter-rouge">ScriptTextOut</code> - to display the glyphs</li>
</ol>

<h2 id="4-scriptshape">4. ScriptShape</h2>

<p>Of all the Uniscribe functions, <code class="highlighter-rouge">ScriptShape</code> is probably the most important. It’s purpose is to convert a run of Unicode characters into a series of <em>glyphs</em> ready for display. <code class="highlighter-rouge">ScriptShape</code> supersedes the functionality provided by the <code class="highlighter-rouge">GetCharacterPlacement</code> API but is quite similar in the type of data it returns.</p>

<p><code class="highlighter-rouge">ScriptShape</code> is a fairly complicated function. It takes as input a single run of text (as identified by the <code class="highlighter-rouge">SCRIPT_ITEM</code> / <code class="highlighter-rouge">ITEM_RUN</code> structures), and also the <code class="highlighter-rouge">SCRIPT_ANALYSIS</code> structure associated with each item-run.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">WINAPI</span> <span class="n">ScriptShape</span><span class="p">(</span>
   <span class="n">HDC</span> <span class="n">hdc</span><span class="p">,</span> 
   <span class="n">SCRIPT_CACHE</span> <span class="o">*</span> <span class="n">psc</span><span class="p">,</span> 
   <span class="k">const</span> <span class="n">WCHAR</span> <span class="o">*</span> <span class="n">pwsChars</span><span class="p">,</span> <span class="c1">// in
</span>   <span class="kt">int</span> <span class="n">cChars</span><span class="p">,</span> 
   <span class="kt">int</span> <span class="n">cMaxGlyphs</span><span class="p">,</span> 
   <span class="n">SCRIPT_ANALYSIS</span> <span class="o">*</span> <span class="n">analysis</span><span class="p">,</span> <span class="c1">// in
</span>   <span class="n">WORD</span> <span class="o">*</span> <span class="n">pwOutGlyphs</span><span class="p">,</span> <span class="c1">// out - array of glyphs
</span>   <span class="n">WORD</span> <span class="o">*</span> <span class="n">pwLogClust</span><span class="p">,</span> <span class="c1">// out - glyph cluster positions
</span>   <span class="n">SCRIPT_VISATTR</span> <span class="o">*</span> <span class="n">psva</span><span class="p">,</span> <span class="c1">// out - visual attributes
</span>   <span class="kt">int</span> <span class="o">*</span> <span class="n">pcGlyphs</span> <span class="c1">// out - count of glyphs
</span><span class="p">);</span>
</code></pre></div></div>

<p>Calling this function results in a bewildering array of information. Let’s look at each parameter in turn to understand what they represent.</p>

<ul>
  <li><code class="highlighter-rouge">psc</code> is a pointer to a <code class="highlighter-rouge">SCRIPT_CACHE</code> object. This object must be intialized to NULL before <code class="highlighter-rouge">ScriptShape</code> is called for the first time.</li>
  <li><code class="highlighter-rouge">pwsChars</code> and <code class="highlighter-rouge">cChars</code> together identify the range of Unicode text (from the original character string) that makes up the current run.</li>
  <li><code class="highlighter-rouge">analysis</code> is a pointer to the <code class="highlighter-rouge">SCRIPT_ANALYSIS</code> structure for each run.</li>
  <li><code class="highlighter-rouge">pwOutGlyphs[]</code> is a buffer <code class="highlighter-rouge">of WORD</code> values, which receives the “glyph-indices” that make up the run. A glyph-index is a value unique to a particular font - it is the value which identifies a particular glyph image in that font. The size of the <code class="highlighter-rouge">pwOutGlyphs</code> buffer must be specified with the <code class="highlighter-rouge">cMaxGlyphs</code> parameter. When <code class="highlighter-rouge">ScriptShape</code> returns, the number of items stored in <code class="highlighter-rouge">pwOutGlyphs</code> is returned in <code class="highlighter-rouge">*pcGlyphs</code>.</li>
  <li><code class="highlighter-rouge">psva[]</code> points to a buffer of <code class="highlighter-rouge">SCRIPT_VISATTR</code> structures. This array runs parallel to the glyph-list (<code class="highlighter-rouge">pwOutGlyphs</code>), so must be allocated to the same size. Other than being a required input to <code class="highlighter-rouge">ScriptPlace</code>, I haven’t found any use for the <code class="highlighter-rouge">SCRIPT_VISATTR</code> information so far.</li>
  <li><code class="highlighter-rouge">pwLogClust[]</code> is an array of WORD values. There is one <code class="highlighter-rouge">WORD</code> for every character (16bit <code class="highlighter-rouge">WCHAR</code>) in the run of text, so each element of <code class="highlighter-rouge">pwLogClust</code> corresponds exactly to a character position within the original text. This also means that the size of the <code class="highlighter-rouge">pwLogClust</code> buffer must be the same length as the run of text - <code class="highlighter-rouge">cChars</code> units long to be exact.</li>
</ul>

<p>The most important parameter here is the <code class="highlighter-rouge">pwLogClust[]</code> array, the contents of which can be used to map between logical character positions and glyph-cluster positions. We will be looking at this array in more detail in the next tutorial.</p>

<h2 id="font-fallback">Font Fallback</h2>

<p>The majority of fonts do not support the full range of characters as defined by Unicode. In fact I don’t know of any font which can display all Unicode scripts and languages. One of the nearest is “Arial Unicode MS” - which is available on the Microsoft Office CDs - but even this font only has around 55,000 characters available. Missing glyphs in a font usually (but not always) results in those little square boxes being displayed.</p>

<p>Applications usually solve this problem by utilizing specific fonts for each Unicode script type. This process is referred to as Font Fallback, and is implemented when the primary display font (say, for a text-editor) does not contain the appropriate glyphs to render all characters in a string. An internal lookup-table is searched for a ‘backup font’, from which the required glyphs can be substituted in favour of the missing glyphs in the primary font.</p>

<p>Font-fallback is not handled by the low-level Uniscribe API - only the ScriptString API has this facility. All Uniscribe-based applications are therefore required to have a built-in list of fallback fonts. For this reason I have decided not to implement Font-fallback in UspLib. It will be Neatpad’s responsibility to handle font-fallback, and substitute fonts can be specified in the ATTR style-runs when analysing each line of text.</p>

<h2 id="5-scriptplace">5. ScriptPlace</h2>

<p><code class="highlighter-rouge">ScriptPlace</code> takes the output of <code class="highlighter-rouge">ScriptShape</code> (the glyph-index-list and <code class="highlighter-rouge">SCRIPT_VISATTR</code> list) and generates glyph <em>advance-width</em> information. <em>Advance-widths</em> are simply the offset in pixels from one glyph to the next. This information is returned in an array of integers (<code class="highlighter-rouge">piAdvance</code>), which can be used to position the output coordinates when displaying text and also for mouse hit-testing.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HRESULT</span> <span class="n">WINAPI</span> <span class="n">ScriptPlace</span><span class="p">(</span>
   <span class="n">HDC</span> <span class="n">hdc</span><span class="p">,</span> 
   <span class="n">SCRIPT_CACHE</span> <span class="o">*</span> <span class="n">psc</span><span class="p">,</span> 
   <span class="n">WORD</span> <span class="o">*</span> <span class="n">pwGlyphs</span><span class="p">,</span> <span class="c1">// in - the results from ScriptShape
</span>   <span class="kt">int</span> <span class="n">cGlyphs</span><span class="p">,</span> <span class="c1">// in - number of glyphs in pwGlyphs
</span>   <span class="n">SCRIPT_VISATTR</span> <span class="o">*</span> <span class="n">psva</span><span class="p">,</span> <span class="c1">// in - from ScriptShape
</span>   <span class="n">SCRIPT_ANALYSIS</span> <span class="o">*</span> <span class="n">analysis</span><span class="p">,</span> <span class="c1">// in - from the ITEM_RUN
</span>   <span class="kt">int</span> <span class="o">*</span> <span class="n">piAdvance</span><span class="p">,</span> <span class="c1">// out - array of advance widths
</span>   <span class="n">GOFFSET</span> <span class="o">*</span> <span class="n">pGoffset</span><span class="p">,</span> <span class="c1">// out - array of GOFFSETs
</span>   <span class="n">ABC</span> <span class="o">*</span> <span class="n">pABC</span> <span class="c1">// out - pointer to a single ABC structure
</span><span class="p">);</span>
</code></pre></div></div>

<p>Instead of accepting a buffer of <code class="highlighter-rouge">WCHAR</code> characters as input (as did <code class="highlighter-rouge">ScriptShape</code>), <code class="highlighter-rouge">ScriptPlace</code> requires the buffer of glyph-indices that were produced by ScriptShape. The parameters of note are:</p>

<ul>
  <li><code class="highlighter-rouge">pwGlyphs[]</code> (and the corresponding <code class="highlighter-rouge">cGlyphs</code>) is the same array of glyphs as returned by <code class="highlighter-rouge">ScriptShape</code>.</li>
  <li><code class="highlighter-rouge">psva</code> [] is the <code class="highlighter-rouge">SCRIPT_VISATTR</code> array returned by <code class="highlighter-rouge">ScriptShape</code>.</li>
  <li><code class="highlighter-rouge">piAdvance[]</code> points to a buffer of integers, which will receive the list of advance-widths for the run. There is one entry in <code class="highlighter-rouge">piAdvance</code> for each glyph in <code class="highlighter-rouge">pwGlyphs</code>. The <code class="highlighter-rouge">piAdvance</code> array must therefore be allocated to the same size as <code class="highlighter-rouge">pwGlyphs</code>.</li>
  <li><code class="highlighter-rouge">pGoffset[]</code> points to a buffer of <code class="highlighter-rouge">GOFFSET</code> structures. These structures identify the offset of each glyph as it should be displayed. MSDN confusingly documents this parameter as a single <code class="highlighter-rouge">GOFFSET</code> structure - however <code class="highlighter-rouge">pGoffset</code> must also be allocated to the same length as the <code class="highlighter-rouge">pwGlyphs</code> array.</li>
</ul>

<p>Finally, the width of the item-run is represented by the <code class="highlighter-rouge">ABC</code> structure pointed to by the <code class="highlighter-rouge">pABC</code> parameter. The total width of each run can be calculated using the following expression:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">runWidth</span> <span class="o">=</span> <span class="n">abc</span><span class="p">.</span><span class="n">abcA</span> <span class="o">+</span> <span class="n">abc</span><span class="p">.</span><span class="n">abcB</span> <span class="o">+</span> <span class="n">abc</span><span class="p">.</span><span class="n">abcC</span><span class="p">;</span>
</code></pre></div></div>

<p>Note that the same value can also be calculated by summing together all of the integers in the <code class="highlighter-rouge">piAdvance</code> array.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">uspData</span><span class="o">-&gt;</span><span class="n">itemRunCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">ShapeAndPlaceItemRun</span><span class="p">(</span><span class="n">hdc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uspData</span><span class="o">-&gt;</span><span class="n">itemRunList</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ScriptPlace</code> is so dependent on the results of <code class="highlighter-rouge">ScriptShape</code> that the two functions are usually called together and isolated in a wrapper function. The <code class="highlighter-rouge">ShapeAndPlaceItemRun</code> function is used to this effect, and is called once for each item-run in the string.</p>

<h2 id="tab-expansion">Tab Expansion</h2>

<p>Handling tabs is really easy with Uniscribe, even though there is no built-in support. The thing to understand is, any character in the original text-string will always be represented by at least one glyph after <code class="highlighter-rouge">ScriptShape</code> is called. This is even true for non-displayable control-characters such as carriage-returns, spaces, and of course tab characters.</p>

<p>To illustrate this idea, an example string “Hello” will be used, in which has two TAB characters embedded:</p>

<p><img src="https://www.catch22.net/assets/img/editor1304.gif" alt="&lt;&gt;" /></p>

<p>The table below holds the results after calling <code class="highlighter-rouge">ScriptShape</code> and <code class="highlighter-rouge">ScriptPlace</code> on this text-string:</p>

<table>
  <tbody>
    <tr>
      <td>Array</td>
      <td>[0]</td>
      <td>[1]</td>
      <td>[2]</td>
      <td>[3]</td>
      <td>[4]</td>
      <td>[5]</td>
      <td>[6]</td>
    </tr>
    <tr>
      <td><strong>pwGlyphs[]</strong></td>
      <td>43</td>
      <td>3</td>
      <td>72</td>
      <td>79</td>
      <td>3</td>
      <td>79</td>
      <td>82</td>
    </tr>
    <tr>
      <td><strong>piAdvance[]</strong></td>
      <td>165</td>
      <td>0</td>
      <td>102</td>
      <td>64</td>
      <td>0</td>
      <td>64</td>
      <td>115</td>
    </tr>
  </tbody>
</table>

<p>Notice that the tab-characters have both been represented by a glyph-index of “3”. Although this glyph-index is only valid for a specific font, it represents the ‘non-displaying’ glyph - that is, a glyph with no visual representation. More interesting though is the resulting widths of these ‘invisible’ glyphs, which are initially set to zero “0”.</p>

<p>The normal course of action once we have got to this stage is to call <code class="highlighter-rouge">ScriptTextOut</code>, with the generated widths+glyphs shown above. This would result in the following:</p>

<p><img src="https://www.catch22.net/assets/img/editor1305.gif" alt="&lt;&gt;" /></p>

<p>The dotted-outline is purely used here to bring across the concept of each glyph being an individual entity. Also notice the two vertical bars which are supposed to represent the (currently) zero-width tab characters.</p>

<p><img src="https://www.catch22.net/assets/img/editor1306.gif" alt="&lt;&gt;" /></p>

<p>The process of tab-expansion is straight-forward. All we need to do is to modify the individual width-entries for tabs inside the width-list. Once this is done all drawing and mouse hit-testing will use the modified glyph-widths, resulting in extra space being allocated where the tab characters would be.</p>

<p>Tab-expansion must obviously occur after <code class="highlighter-rouge">ScriptShape</code> and <code class="highlighter-rouge">ScriptPlace</code> have been called. After all item-runs have been processed in this way, UspAnalyze calls another internal function - ExpandTabs:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">ExpandTabs</span><span class="p">(</span><span class="n">USPDATA</span> <span class="o">*</span><span class="n">uspData</span><span class="p">,</span> <span class="n">WCHAR</span> <span class="o">*</span><span class="n">wstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">SCRIPT_TABDEF</span> <span class="o">*</span><span class="n">tabdef</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SCRIPT_TABDEF</code> is a standard Uniscribe structure used for <code class="highlighter-rouge">ScriptStringAnalyze</code>. It contains information about the tab-stops in a string (size and locations). I have used this same structure for UspLib purely to be consistent.</p>

<h2 id="applying-attributes">Applying Attributes</h2>

<p>UspLib supports variable length attribute-runs when styling a string of Unicode text, using an array of <code class="highlighter-rouge">ATTR</code> structures. Although Neatpad does not take advantage of this facility (it just sets each ATTR to “1” unit long), the possibility still exists for variable-length runs to be specified.</p>

<p><img src="https://www.catch22.net/assets/img/editor1307.gif" alt="&lt;&gt;" /></p>

<p>Whilst this is not a problem in itself, processing variable length style-runs at the same time as displaying runs of glyphs can get very complicated. To simplify this matter UspLib always <em>flattens</em> any user-supplied attribute-run, and keeps an internal copy inside the <code class="highlighter-rouge">USPDATA</code> object. The flattened run-list is allocated to the same length as the original Unicode string, and contains exactly one <code class="highlighter-rouge">ATTR</code> structure per original Unicode character.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UspApplyAttributes</span><span class="p">(</span><span class="n">USPDATA</span> <span class="o">*</span><span class="n">uspData</span><span class="p">,</span> <span class="n">ATTR</span> <span class="o">*</span><span class="n">attrRunList</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">UspApplyAttributes</code> (above) is used to update the style-run information belonging to a <code class="highlighter-rouge">USPDATA</code> object, and is called by <code class="highlighter-rouge">UspAnalyze</code> as part of the string-analysis process. However this function can be called at any time after a string has been analyzed. Note that only the colour-information is updated on subsequent calls to <code class="highlighter-rouge">UspApplyAttributes</code> - as reapplying font information would require the entire string to be re-analyzed.</p>

<h2 id="uspanalyze">UspAnalyze</h2>

<p>We have now covered enough ground to complete the implementation of UspAnalyze. All of the related code for this analysis phase is located in the <code class="highlighter-rouge">UspLib.c</code> file. The functional break-down of the analysis is shown below.</p>

<p><img src="https://www.catch22.net/assets/img/editor1303.gif" alt="&lt;&gt;" /></p>

<p>The result of all this work is a single <code class="highlighter-rouge">USPDATA</code> object, which contains <em>all</em> of the information necessary to display a string of Unicode text.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_USPDATA</span>
<span class="p">{</span>
  <span class="c1">//
</span>  <span class="c1">// Item-run information 
</span>  <span class="c1">//
</span>  <span class="kt">int</span> <span class="n">itemRunCount</span><span class="p">;</span>
  <span class="n">ITEM_RUN</span> <span class="o">*</span> <span class="n">itemRunList</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">visualToLogicalList</span><span class="p">;</span>

  <span class="c1">//
</span>  <span class="c1">// Logical character/cluster information (1 unit per original WCHAR)
</span>  <span class="c1">//
</span>  <span class="kt">int</span> <span class="n">stringLen</span><span class="p">;</span> <span class="c1">// length of current string (in WCHARs)
</span>  <span class="n">WORD</span> <span class="o">*</span> <span class="n">clusterList</span><span class="p">;</span> <span class="c1">// logical cluster info
</span>  <span class="n">ATTR</span> <span class="o">*</span> <span class="n">attrList</span><span class="p">;</span> <span class="c1">// flattened attribute-list
</span>
  <span class="c1">//
</span>  <span class="c1">// Glyph information for the entire paragraph
</span>  <span class="c1">// Each ITEM_RUN references a position within these lists:
</span>  <span class="c1">//
</span>  <span class="kt">int</span> <span class="n">glyphCount</span><span class="p">;</span> <span class="c1">// count of glyphs currently stored
</span>  <span class="n">WORD</span> <span class="o">*</span> <span class="n">glyphList</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">widthList</span><span class="p">;</span>
  <span class="n">GOFFSET</span> <span class="o">*</span> <span class="n">offsetList</span><span class="p">;</span>
  <span class="n">SCRIPT_VISATTR</span> <span class="o">*</span> <span class="n">svaList</span><span class="p">;</span>

  <span class="c1">//
</span>  <span class="c1">// external, user-maintained font-table
</span>  <span class="c1">//
</span>  <span class="n">USPFONT</span> <span class="o">*</span> <span class="n">uspFontList</span><span class="p">;</span>

<span class="p">}</span> <span class="n">USPDATA</span><span class="p">,</span> <span class="o">*</span><span class="n">PUSPDATA</span><span class="p">;</span>
</code></pre></div></div>

<p>The listing above details the <code class="highlighter-rouge">USPDATA</code> structure. For the purposes of clarity I have omitted several ‘house-keeping’ fields which are not required for this discussion.</p>

<p>One of the major difficulties when dealing with Uniscribe is knowing what to do with the huge amount of information that is generated. The strategy that I have taken with UspLib is to keep all information inside the USPDATA object. The “per-run” glyph information is concatenated into several large buffers (<code class="highlighter-rouge">glyphList</code>, <code class="highlighter-rouge">widthList</code> etc). Each <code class="highlighter-rouge">ITEM_RUN</code> refers to a certain range of data within each of these large buffers, using the <code class="highlighter-rouge">ITEM_RUN::glyphPos</code> and <code class="highlighter-rouge">ITEM_RUN::glyphCount</code> fields.</p>

<p>There are basically two approaches with Uniscribe - and can be categorized as Speed vs Memory consumption. The first strategy is to gather together all the information generated by the Uniscribe APIs into one object. This has the advantage of being quick in operation, because the ‘analysis’ phase (itemization, shaping etc) happens one time only. After this the glyph data is stored away and then reused each time the text is displayed.</p>

<p>The other approach is to conserve memory, by only allocating buffers when necessary, and repeatedly calling ScriptShape/Place each time glyph information is required. The advantage has already been mentioned, but the disadvantage is performance loss. Re-shaping item-runs each time they are displayed will be quite alot slower - and considering that a text-editor will need to redraw it’s display every time the mouse-selection changes, this strategy is something that I want to avoid.</p>

<p>For UspLib I have opted for the speed (resource-heavy) approach.</p>

<h2 id="coming-up-in-part-14">Coming up in Part 14</h2>

<p>We still haven’t drawn any text but it won’t be long before we do. The next tutorial will focus on the <code class="highlighter-rouge">UspTextOut</code> function, and will demonstrate how to display styled Unicode text by taking the output from <code class="highlighter-rouge">ScriptShape</code> and <code class="highlighter-rouge">ScriptPlace</code>, and applying the attribute-runs stored in the <code class="highlighter-rouge">USPDATA</code> object.</p>



        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2006-03-02T00:00:00+00:00">March 02, 2006</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="uniscribe-mysteries.html" class="pagination--pager" title="Uniscribe Mysteries
">Previous</a>
    
    
      <a href="drawing-styled-text-uniscribe.html" class="pagination--pager" title="Drawing styled text with Uniscribe
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="https://www.catch22.net/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Catch22. Powered by <a href="https://jekyllrb.com/" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://www.catch22.net/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>








  </body>

<!-- Mirrored from www.catch22.net/tuts/neatpad/more-uniscribe-mysteries by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:41 GMT -->
</html>
