<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  
<!-- Mirrored from www.catch22.net/tuts/neatpad/loading-text-file by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Loading a text file - Catch22</title>
<meta name="description" content="Introduction">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Catch22">
<meta property="og:title" content="Loading a text file">
<meta property="og:url" content="loading-text-file.html">


  <meta property="og:description" content="Introduction">







  <meta property="article:published_time" content="2005-02-18T00:00:00+00:00">






<link rel="canonical" href="loading-text-file.html">













<!-- end _includes/seo.html -->


<link href="https://www.catch22.net/feed.xml" type="application/atom+xml" rel="alternate" title="Catch22 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://www.catch22.net/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--tutorial wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="https://www.catch22.net/">Catch22</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://www.catch22.net/blog/" >Blog</a>
            </li><li class="masthead__menu-item">
              <a href="https://www.catch22.net/software/" >Software</a>
            </li><li class="masthead__menu-item">
              <a href="../index.html" >Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="https://www.catch22.net/about/" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="http://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="http://www.catch22.net/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="https://www.catch22.net/tuts" itemprop="item"><span itemprop="name">Tuts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
          <a href="../neatpad.html" itemprop="item"><span itemprop="name">Neatpad</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        <li class="current">Loading a text file</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      
  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="https://www.catch22.net/assets/files/tuts/neatpad/neatpad2.zip">neatpad2.zip</a>      
    
  </div>

    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Neatpad</span>
        

        
        <ul>
          
            
            

            
            

            <li><a href="#" class=""></a></li>
          
            
            

            
            

            <li><a href="neatpad-overview.html" class="">Neatpad Overview</a></li>
          
            
            

            
            

            <li><a href="loading-text-file.html" class="active">Loading a text file</a></li>
          
            
            

            
            

            <li><a href="scrollbars-scrolling.html" class="">Scrollbars & Scrolling</a></li>
          
            
            

            
            

            <li><a href="enhanced-drawing-painting.html" class="">Enhanced Drawing & Painting</a></li>
          
            
            

            
            

            <li><a href="mouse-selection-highlighting.html" class="">Mouse Selection & Highlighting</a></li>
          
            
            

            
            

            <li><a href="scrolling-mouse.html" class="">Scrolling with the Mouse</a></li>
          
            
            

            
            

            <li><a href="margins-and-long-lines.html" class="">Margins and Long Lines</a></li>
          
            
            

            
            

            <li><a href="introduction-unicode.html" class="">Introduction to Unicode</a></li>
          
            
            

            
            

            <li><a href="unicode-text-processing.html" class="">Unicode Text Processing</a></li>
          
            
            

            
            

            <li><a href="transparent-text.html" class="">Transparent Text</a></li>
          
            
            

            
            

            <li><a href="introduction-uniscribe.html" class="">Introduction to Uniscribe</a></li>
          
            
            

            
            

            <li><a href="uniscribe-mysteries.html" class="">Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="more-uniscribe-mysteries.html" class="">More Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="drawing-styled-text-uniscribe.html" class="">Drawing styled text with Uniscribe</a></li>
          
            
            

            
            

            <li><a href="integrating-usplib.html" class="">Integrating UspLib</a></li>
          
            
            

            
            

            <li><a href="keyboard-navigation.html" class="">Keyboard Navigation</a></li>
          
            
            

            
            

            <li><a href="piece-chains.html" class="">Piece Chains</a></li>
          
            
            

            
            

            <li><a href="unicode-text-editing.html" class="">Unicode Text Editing</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>
    

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Loading a text file">
    <meta itemprop="description" content="Introduction">
    <meta itemprop="datePublished" content="February 18, 2005">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Loading a text file
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <!--h1>Loading a text file</h1-->
<!--h3>Loading and displaying a text file</h3-->

<h2 id="introduction">Introduction</h2>

<p>This is the second part of the “Design and Implementation of a Win32 Text Editor” article series. If you haven’t already read part 1 then please do so now!</p>

<p>OK, so assuming you’ve downloaded, assimilated and compiled the source code that was made available, you should have a basic skeleton text editor which doesn’t do anything yet. Our mission in part 2 is to load a text file into memory and display it in our TextView control. But let’s not get carried away. The only aim right now is to load a text file and provide very basic display, we are nowhere near providing scrolling or keyboard and mouse support.</p>

<h2 id="text-documents">Text Documents</h2>

<p>A Text Document is nothing more than a basic binary file, with the commonly understood convention that a text-file should not contain unprintable characters (i.e. ASCII control characters), and that lines of text are separated by a common end-of-line delimiter (such as a carriage-return / line-feed pair).</p>

<p>It is the task of a Text Editor to interpret a text-file’s binary content and display this content in a line-oriented manner to the user. Part one of this tutorial series discussed the structure of a Text Editor - and described the TextView and TextDocument objects. The first thing we will concentrate on will therefore be the <code class="highlighter-rouge">TextDocument</code> object - which we will represent as a C++ class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextDocument</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>

    <span class="n">ULONG</span> <span class="n">getline</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">lineno</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">ULONG</span> <span class="n">linecount</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">init_linebuffer</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The basic C++ interface is very simple. We can load a file into the TextDocument using the <code class="highlighter-rouge">init</code> class member. We can retrieve a line of text using the <code class="highlighter-rouge">getline</code> method - where we specify a line number and a buffer into which to store the line contents.</p>

<p>Notice that the TextDocument class is entirely ASCII in operation at the moment - that is, there is no support for Unicode. We could have used C++ templates to support a variety of different types. However at this moment in time I am still undecided as to how best approach this problem, so we will leave the interface as simple as possible. After all, this is a “throw-away” implementation of TextDocument, and we will completely re-write it later on in the series.</p>

<h2 id="loading-a-text-file">Loading a text file</h2>

<p>Our first attempt at loading a text file will try to be as simple as possible. The <code class="highlighter-rouge">TextDocument::init</code> function below is the main interface to the TextDocument:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">TextDocument</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hFile</span><span class="p">;</span>
    <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">init</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">TextDocument::init</code> simply opens a file using the standard win32 <code class="highlighter-rouge">CreateFile</code> API, and then passes control to a helper function which loads the file contents using the HANDLE returned by <code class="highlighter-rouge">CreateFile</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">TextDocument</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">numread</span><span class="p">;</span>

    <span class="k">if</span><span class="p">((</span><span class="n">length</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// allocate new file-buffer
</span>    <span class="k">if</span><span class="p">((</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">length</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// read entire file into memory
</span>    <span class="n">ReadFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numread</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// work out where each line of text starts
</span>    <span class="n">init_linebuffer</span><span class="p">();</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see loading a file is very simple. We calculate how big the file is, allocate a buffer to hold the text, and then read the file into memory. This is not really a very smart thing to do, as large files will take a very long time to load, or may fail to load completely if there isn’t enough memory available.</p>

<p>Please understand that this is a “throw-away” TextDocument class. Writing a TextDocument class which supports files of any size will be very difficult so I have deliberately kept this version of TextDocument as simple as possible. Later on in the series we will revisit file-loading and write this class properly.</p>

<h2 id="carriage-returns-and-linefeeds">Carriage-returns and Linefeeds</h2>

<p>How many lines are there in a text document? How do we read a file line-by-line? The answer really depends on how you define what a line of text is. At it’s simplest, a line of text is a sequence of characters within a file, with well-defined end of line marker. We don’t really care what the characters are in each line, but we do need to know how to identify where the start and stop of each line is.</p>

<p>There are three main conventions for delimiting lines of text - under DOS and Windows, a carriage-return / line-feed pair is used. Under UNIX and Linux, a single line-feed character is used, and under Macintosh operating system, a single carriage-return is used. There are a number of issues which become apparent once we try to tackle all these cases, but for now we will just concentrate on the DOS/Windows case. A future tutorial will address the other last two options (and another case, where we can encounter a file with all combinations of line-separators).</p>

<p>The TextView control needs to know now many lines of text there are in it’s document, because it must be able to setup the scrollbars to reflect the document length. We also need to be able to locate individual lines of text in a random order because we will be drawing the text document line-by-line.</p>

<p>The most common solution to this problem is to implement what is known as a “line buffer”. Conceptually the line buffer is very simple - it is just an array of integer offsets which specify where each line of text in the document starts.</p>

<p><img src="https://www.catch22.net/assets/img/editor09.gif" alt="&lt;&gt;" /></p>

<p>The diagram above illustrates a line-buffer on the left hand side. The buffer has been initialized with the block of text on the right - by processing the text, searching for carriage-return / line-feed sequences, and recording the offset for each line. Each array item (numbered 0-6) contains the offset of the character which starts each line of text.</p>

<p>The <code class="highlighter-rouge">TextDocument</code> will implement the line-buffer as it seems a natural choice to perform line-parsing in the same place as the file loading. The <code class="highlighter-rouge">TextDocument::init_linebuffer</code> function below is called when a new file is loaded:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">TextDocument</span><span class="o">::</span><span class="n">init_linebuffer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">linestart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// allocate the line-buffer
</span>    <span class="k">if</span><span class="p">((</span><span class="n">linebuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ULONG</span><span class="p">[</span><span class="n">length</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">numlines</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// loop through every byte in the file
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\r'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// carriage-return / line-feed combination
</span>            <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// record where the line starts
</span>            <span class="n">linebuffer</span><span class="p">[</span><span class="n">numlines</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">linestart</span><span class="p">;</span>
            <span class="n">linestart</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">linebuf</span><span class="p">[</span><span class="n">numlines</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">init_linebuffer</code> function does two things: allocate space for the line buffer, and then process the file. Because we don’t know how many lines of text there will be until we process the entire file, how do we know how big to make the line-buffer? The short answer is, we can’t possibly know this. A real TextDocument class would either dynamically reallocate it’s line-buffer as it encountered more lines, or use some clever algorithms to limit the amount of memory consumed by the line-buffer.</p>

<p>For now we will cheat and make the linebuffer the same size as the file itself - this way we know we won’t run out of space. Processing the file requires us to loop through each and every byte in the file, looking for a carriage-return character.</p>

<p>The algorithm itself is straight-forward. Whenever a carriage-return is encountered (followed by an optional line-feed), a new entry is added to the end of the linebuffer, which records the current start-of-line. The linestart variable is then made to “point” to the character after the carriage-return - the start of the next line. This continues until there are no more characters left in the file. The number of lines processed is kept updated in the <code class="highlighter-rouge">numlines</code> variable.</p>

<h2 id="retrieving-lines-of-text">Retrieving lines of text</h2>

<p>Now that our TextDocument implements a rudimentary line buffer, line-based lookups will be very fast. The following <code class="highlighter-rouge">TextDocument::getline</code> function shows how we will access each line of text from the TextDocument:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONG</span> <span class="n">TextDocument</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">lineno</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">lineptr</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">linelen</span><span class="p">;</span>

    <span class="c1">// find the start of the specified line
</span>    <span class="n">lineptr</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">linebuffer</span><span class="p">[</span><span class="n">lineno</span><span class="p">];</span>

    <span class="c1">// work out how long it is, by looking at the next line's starting point
</span>    <span class="n">linelen</span> <span class="o">=</span> <span class="n">linebuffer</span><span class="p">[</span><span class="n">lineno</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">linebuffer</span><span class="p">[</span><span class="n">lineno</span><span class="p">];</span>

    <span class="c1">// make sure we don't overflow caller's buffer
</span>    <span class="n">linelen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">linelen</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lineptr</span><span class="p">,</span> <span class="n">linelen</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">linelen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function works by using the <code class="highlighter-rouge">lineno</code> parameter as a direct index into the <code class="highlighter-rouge">linebuffer</code> array. The offset stored in <code class="highlighter-rouge">linebuffer[lineno]</code> is added to the real buffer of text, resulting in a pointer to the start-of-line. The length of the line (in characters) is calculated by subtracting the <em>next</em> line’s offset from the current line’s. Once the correct offset and length have been calculated, the raw line content is copied into the caller-supplied buffer. It’s simple but it works.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
<span class="n">m_pTextDocument</span><span class="o">-&gt;</span><span class="n">getline</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</code></pre></div></div>

<p>The example above shows how to retrieve a buffer of text at line number 5.</p>

<h2 id="drawing-the-lines-of-text">Drawing the lines of text</h2>

<p>The whole point of accessing the TextDocument in a line-by-line manner is to make our lives simpler when it comes to drawing the text in our TextView control.</p>

<p>The entire drawing and painting logic in our TextView will be centered around the <code class="highlighter-rouge">WM_PAINT</code> message. In fact, our <code class="highlighter-rouge">WM_PAINT</code> handler will be the only place in the entire program where any form of painting takes place. As with every win32 program, the painting framework starts life as a basic BeginPaint / EndPaint sequence:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LONG</span> <span class="n">TextView</span><span class="o">::</span><span class="n">OnPaint</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PAINTSTRUCT</span> <span class="n">ps</span><span class="p">;</span>

    <span class="n">BeginPaint</span><span class="p">(</span><span class="n">m_hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>

    <span class="c1">// do painting
</span>    <span class="n">EndPaint</span><span class="p">(</span><span class="n">m_hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function above simply validates the device-context and returns - and because our window-class for the TextView specified that there is no background brush, not even a single pixel is displayed.</p>

<p>At this point, all we have is a basic drawing framework, with the update-area specified in the <code class="highlighter-rouge">PAINTSTRUCT::rcPaint</code> RECT structure. The diagram below illustrates this update rectangle in red.</p>

<p><img src="https://www.catch22.net/assets/img/editor05.gif" alt="&lt;&gt;" /></p>

<p>Our task is to take this single, arbitrary rectangular region and convert it into a series of horizontal <em>spans</em> that will be filled with lines of text. In the diagram above the update region has been split into three such <em>spans</em>. The variables <code class="highlighter-rouge">first</code> and <code class="highlighter-rouge">last</code> denote the first and last lines that require updating.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LONG</span> <span class="n">TextView</span><span class="o">::</span><span class="n">OnPaint</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PAINTSTRUCT</span> <span class="n">ps</span><span class="p">;</span>

    <span class="n">BeginPaint</span><span class="p">(</span><span class="n">m_hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>

    <span class="n">ULONG</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>

    <span class="c1">// figure out which lines to draw
</span>    <span class="n">first</span> <span class="o">=</span> <span class="n">ps</span><span class="p">.</span><span class="n">rcPaint</span><span class="p">.</span><span class="n">top</span> <span class="o">/</span> <span class="n">m_nFontHeight</span><span class="p">;</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">ps</span><span class="p">.</span><span class="n">rcPaint</span><span class="p">.</span><span class="n">bottom</span> <span class="o">/</span> <span class="n">m_nFontHeight</span><span class="p">;</span>

    <span class="c1">// draw the display line-by-line
</span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PaintLine</span><span class="p">(</span><span class="n">ps</span><span class="p">.</span><span class="n">hdc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">EndPaint</span><span class="p">(</span><span class="n">m_hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The OnPaint code above is simple but effective. The first two lines we added were “<code class="highlighter-rouge">first =</code> “ and “<code class="highlighter-rouge">last =</code> “. These are used to work out the starting and ending row which encompass the update region. We divide by the current font-height because we want to convert from pixels to logical lines.</p>

<p>Note that we have <em>not</em> taken into account the horizontal extents of the update region. This is deliberate, as it is simpler at this stage to draw each line in it’s entirety, and let the device-context’s update-region clip our output if we draw too much.</p>

<p>The individual line drawing has been deferred to separate function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LONG</span> <span class="n">TextView</span><span class="o">::</span><span class="n">PaintLine</span><span class="p">(</span><span class="n">HDC</span> <span class="n">hdc</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">nLineNo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TCHAR</span> <span class="n">buf</span><span class="p">[</span><span class="n">LONGEST_LINE</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">len</span><span class="p">;</span>

    <span class="n">RECT</span> <span class="n">rect</span><span class="p">;</span>
    <span class="n">GetClientRect</span><span class="p">(</span><span class="n">m_hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>

    <span class="c1">// work out where the line should be drawn
</span>    <span class="n">rect</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">nLineNo</span> <span class="o">*</span> <span class="n">m_nFontHeight</span><span class="p">;</span>
    <span class="n">rect</span><span class="p">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="n">m_nFontHeight</span><span class="p">;</span>

    <span class="c1">// get the data for this single line of text
</span>    <span class="n">len</span> <span class="o">=</span> <span class="n">m_pTextDocument</span><span class="o">-&gt;</span><span class="n">getline</span><span class="p">(</span><span class="n">nLineNo</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">LONGEST_LINE</span><span class="p">);</span>

    <span class="c1">// draw text and erase the entire line background at the same time
</span>    <span class="n">TabbedExtTextOut</span><span class="p">(</span><span class="n">hdc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can see drawing a line of text is relatively simple. The first thing we do is work out the pixel coordinates of where to draw the line. We use the window’s client area as our starting point, and then adjust the top and bottom to describe the line as a simple rectangular region in pixel-based coordinates.</p>

<p>Once we have the line’s bounding rectangle we use a further helper function to draw the text - <code class="highlighter-rouge">TabbedExtTextOut</code>. I won’t include this function here - just look in the sources - suffice to say, TabbedExtTextOut is a simple wrapper function around the <code class="highlighter-rouge">TabbedTextOut</code> API, withthe added feature that it also erases any background area that is not taken up by actual text - similar to the <code class="highlighter-rouge">ExtTextOut</code> API.</p>

<p>The actual line of text we want to draw is retrieved from the TextDocument object using the <code class="highlighter-rouge">getline</code> method we developed earlier. It doesn’t matter if we change how we store our text-file inside the TextDocument, as long as we preserve the “getline” interface the TextView and TextDocument can be entirely separate entities.</p>

<p>Note that our simple text-output at this stage is exactly that - we don’t handle control characters, syntax colouring or scrolling. One step at a time though..</p>

<h2 id="coming-up-in-part-3">Coming up in Part 3</h2>

<p>At this point we have a very simple text-viewing capability, but it is quite limited in what it can do. There is no scrolling, no keyboard or mouse input, no selection or highlighting, no colouring and no editing. Don’t let this discourage you though - it is very important that we have a simple design with which to start off with.</p>

<p>If you are reading this tutorial series then you probably want to see how a real text-storage component is implemented - i.e. how large files are loaded, data structures managed etc. This will be covered in a future tutorial quite soon, but for now I want to get the basic graphical interface working first.</p>

<p>The next tutorial will therefore look at adding scrolling support, so at least we will be able to view an entire text document. Once we have finished that, we will look at mouse input, as this will be one of the most difficult areas to implement. It will require careful coding in both the mouse and drawing routines as we have to handle cursor placement and selection highlighting at the same time.</p>



  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="https://www.catch22.net/assets/files/tuts/neatpad/neatpad2.zip">neatpad2.zip</a>      
    
  </div>

        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2005-02-18T00:00:00+00:00">February 18, 2005</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="neatpad-overview.html" class="pagination--pager" title="Neatpad Overview
">Previous</a>
    
    
      <a href="scrollbars-scrolling.html" class="pagination--pager" title="Scrollbars &amp; Scrolling
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="https://www.catch22.net/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Catch22. Powered by <a href="https://jekyllrb.com/" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://www.catch22.net/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>








  </body>

<!-- Mirrored from www.catch22.net/tuts/neatpad/loading-text-file by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 27 Apr 2022 20:48:41 GMT -->
</html>
